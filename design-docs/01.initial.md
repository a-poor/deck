# Declarative API Server - Design Document

## Overview

A declarative approach to building JSON/HTML APIs and web servers. Instead of writing imperative code, developers define routes, handlers, and data transformations in a JSON configuration file.

**Core Principles:**
- **Declarative over imperative**: Express *what* should happen, not *how*
- **Pipeline-based execution**: Data flows through sequential stages
- **Operator composition**: Small, composable `$` operators that can nest freely
- **Context-aware**: Named variables accessible throughout the pipeline via JSON paths

---

## Configuration Structure

### Top Level

```json
{
  "database": {
    "schemas": {/* collection/table schemas */}
  },
  "templates": {
    "path": "./templates",
    "files": {/* template file references */}
  },
  "routes": [/* route definitions */],
  "middleware": {/* reusable middleware */},
  "schemas": {/* reusable validation schemas */},
  "errorHandlers": {/* TBD */}
}
```

---

## Database Configuration

### Database Schemas

Define the structure of your database collections/tables. These schemas can be used for:
- Validation before inserts/updates
- Auto-generating default CRUD endpoints (future)
- Documentation
- Type information for tooling

```json
{
  "database": {
    "schemas": {
      "posts": {
        "fields": {
          "id": { "type": "string", "required": true, "primary": true },
          "title": { "type": "string", "required": true },
          "body": { "type": "string", "required": true },
          "authorId": { "type": "string", "required": true },
          "published": { "type": "boolean", "default": false },
          "tags": { "type": "array", "items": { "type": "string" } },
          "createdAt": { "type": "datetime", "required": true },
          "updatedAt": { "type": "datetime" }
        },
        "indexes": [
          { "fields": ["authorId"] },
          { "fields": ["published", "createdAt"] }
        ]
      },
      "users": {
        "fields": {
          "id": { "type": "string", "required": true, "primary": true },
          "email": { "type": "string", "required": true, "unique": true },
          "name": { "type": "string", "required": true },
          "avatar": { "type": "string" },
          "role": { "type": "string", "enum": ["user", "admin"], "default": "user" },
          "createdAt": { "type": "datetime", "required": true }
        },
        "indexes": [
          { "fields": ["email"], "unique": true }
        ]
      }
    }
  }
}
```

**Field Types:**
- `string`
- `number`
- `boolean`
- `datetime`
- `array`
- `object`
- `json` (arbitrary JSON data)

**Field Options:**
- `required` - Field must be present
- `primary` - Primary key field
- `unique` - Values must be unique across collection
- `default` - Default value if not provided
- `enum` - Restricted set of allowed values
- `items` - For arrays, defines the type of array elements

**Notes:**
- Database schemas are optional but recommended
- The runtime can use these for validation if enabled
- Future: Auto-generate CRUD endpoints based on schemas

---

## Templates Configuration

Define template files for HTML rendering. Templates are referenced by name in routes.

```json
{
  "templates": {
    "path": "./templates",
    "engine": "jinja",
    "files": {
      "layout": "layout.html",
      "postDetail": "posts/detail.html",
      "postList": "posts/list.html",
      "error404": "errors/404.html"
    }
  }
}
```

**Configuration Options:**
- `path` - Base directory for template files (relative to config file)
- `engine` - Template engine to use (future: `jinja`, `handlebars`, `ejs`, etc.)
- `files` - Named references to template files

**Usage in Routes** (future):
```json
{
  "path": "/posts/:id",
  "method": "GET",
  "pipeline": [
    {
      "name": "post",
      "value": { "$dbQuery": {...} }
    },
    {
      "name": "html",
      "value": {
        "$renderTemplate": {
          "template": "postDetail",
          "data": {
            "post": { "$get": "post" },
            "user": { "$get": "user" }
          }
        }
      }
    }
  ],
  "response": {
    "status": 200,
    "headers": { "Content-Type": "text/html" },
    "body": { "$get": "html" }
  }
}
```

**Notes:**
- Template system design is TBD
- This section reserves the configuration space for future implementation
- Templates can be used for HTML pages, email bodies, etc.

---

## Route Definition

```json
{
  "path": "/api/v1/posts/:id",
  "method": "GET",
  "middleware": ["authenticate", "rateLimit"],
  "pipeline": [/* execution steps */],
  "response": {
    "status": 200,
    "headers": {},
    "body": { "$get": "response" }
  }
}
```

---

## Pipeline Model

Routes execute through a sequential pipeline of steps. Each step can:
- Validate data
- Query/mutate the database
- Transform data
- Branch conditionally
- Store results in the context

### Pipeline Step Structure

```json
{
  "name": "variableName",  // stores result in context
  "value": {/* operator expression */}
}
```

**Note:** The `type` field (e.g., `"type": "validate"`) is still under consideration. It could make pipelines more self-documenting but may be redundant with operator-based syntax.

---

## Context & Variable Model

The pipeline maintains a context object that accumulates data from each step. Variables are accessed using JSON path syntax:

- `params.id` - Path parameters
- `query.page` - Query string parameters
- `headers.authorization` - Request headers
- `body` - Request body
- `user` - Variable added by middleware
- `post` - Variable created in pipeline

Operators reference context using `$get`:
```json
{ "$get": "params.id" }
{ "$get": "user.email" }
```

---

## Operator Reference

All operators use a `$` prefix to distinguish them from regular data.

### Data Access

**`$get`** - Extract value from context
```json
{ "$get": "path.to.value" }
```

### Conditionals & Branching

**`$if`** - Conditional branching
```json
{
  "$if": {
    "condition": { "$exists": { "$get": "post" } },
    "then": { "$get": "post" },
    "else": { "$return": { "status": 404, "body": { "error": "Not found" } } }
  }
}
```

**`$switch`** - Multi-way branching (SQL CASE-like)
```json
{
  "$switch": {
    "on": { "$get": "user.role" },
    "cases": [
      { "when": "admin", "then": { "$get": "fullData" } },
      { "when": "user", "then": { "$get": "limitedData" } }
    ],
    "default": { "$return": { "status": 403 } }
  }
}
```

### Collection Operations

**`$map`** - Transform each item
```json
{
  "$map": {
    "over": { "$get": "posts" },
    "do": {
      "$merge": [
        { "$get": "item" },
        { "url": { "$renderString": "/posts/{{item.id}}" } }
      ]
    }
  }
}
```

**`$filter`** - Filter items
```json
{
  "$filter": {
    "over": { "$get": "posts" },
    "where": { "$eq": [{ "$get": "item.published" }, true] }
  }
}
```

**`$reduce`** - Aggregate/fold (basic support initially)
```json
{
  "$reduce": {
    "over": { "$get": "numbers" },
    "with": { "$add": [{ "$get": "accumulator" }, { "$get": "item" }] },
    "initial": 0
  }
}
```

**Note:** No explicit loops - use collection operators instead.

### Database Operations

Database is treated as a document/key-value store. Records are JSON objects.

**`$dbQuery`** - Query documents
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": { "id": { "$get": "params.id" } },
    "select": ["title", "body", "authorId"],
    "limit": 10
  }
}
```

**`$dbInsert`** - Insert document (returns created record)
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": { "$get": "body.title" },
      "authorId": { "$get": "user.id" },
      "createdAt": { "$now": null }
    }
  }
}
```

**`$dbUpdate`** - Update documents (returns updated records)
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": { "id": { "$get": "params.id" } },
    "update": {
      "title": { "$get": "body.title" },
      "updatedAt": { "$now": null }
    }
  }
}
```

**`$dbDelete`** - Delete documents (returns deleted records)
```json
{
  "$dbDelete": {
    "collection": "posts",
    "filter": { "id": { "$get": "params.id" } }
  }
}
```

**Database Schema Validation:**
If database schemas are defined, the runtime can optionally validate inserts/updates against the schema before executing:

```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": { "$get": "body.title" },
      "body": { "$get": "body.body" },
      "authorId": { "$get": "user.id" },
      "createdAt": { "$now": null }
    },
    "validate": true  // Optional: validate against schema
  }
}
```

### Utility Operators

**`$merge`** - Combine objects
```json
{ "$merge": [{ "$get": "post" }, { "extra": "field" }] }
```

**`$exists`** - Check if value exists/is non-null
```json
{ "$exists": { "$get": "post" } }
```

**`$renderString`** - Template string rendering
```json
{ "$renderString": "Hello {{user.name}}, you have {{user.messageCount}} messages" }
```

**`$return`** - Early return from pipeline
```json
{
  "$return": {
    "status": 404,
    "headers": { "X-Custom": "value" },
    "body": { "error": "Not found" }
  }
}
```

### Operator Composition

Operators can nest freely:
```json
{
  "$map": {
    "over": {
      "$filter": {
        "over": { "$get": "posts" },
        "where": { "$eq": [{ "$get": "item.published" }, true] }
      }
    },
    "do": { "$get": "item.title" }
  }
}
```

---

## Middleware

Middleware are reusable pipeline fragments that can:
1. Add variables to the context (e.g., authenticated user)
2. Short-circuit execution with early return

### Definition

```json
{
  "middleware": {
    "authenticate": {
      "pipeline": [
        {
          "name": "token",
          "value": { "$get": "headers.authorization" }
        },
        {
          "name": "user",
          "value": {
            "$if": {
              "condition": { "$exists": { "$get": "token" } },
              "then": { "$decodeJWT": { "$get": "token" } },
              "else": { "$return": { "status": 401, "body": { "error": "Unauthorized" } } }
            }
          }
        }
      ]
    }
  }
}
```

### Usage

```json
{
  "path": "/api/v1/posts",
  "method": "POST",
  "middleware": ["authenticate", "rateLimit"],
  "pipeline": [
    // $user is now available from authenticate middleware
    { "name": "post", "value": { "$dbInsert": {...} } }
  ]
}
```

**Middleware Execution:**
Middleware can reference `$next` to explicitly continue (TBD - may be implicit unless `$return` is called).

---

## Validation

Validation can happen at any pipeline step. Use JSON Schema or inline validation:

```json
{
  "name": "validatedInput",
  "value": {
    "$validate": {
      "data": { "$get": "body" },
      "schema": {
        "type": "object",
        "properties": {
          "title": { "type": "string", "minLength": 1 },
          "body": { "type": "string" }
        },
        "required": ["title", "body"]
      },
      "onFail": { "$return": { "status": 400, "body": { "error": "Invalid input" } } }
    }
  }
}
```

Or reference reusable schemas:
```json
{
  "schemas": {
    "createPost": {
      "type": "object",
      "properties": {/* ... */}
    }
  },
  "routes": [
    {
      "pipeline": [
        {
          "value": {
            "$validate": {
              "data": { "$get": "body" },
              "schema": { "$ref": "#/schemas/createPost" }
            }
          }
        }
      ]
    }
  ]
}
```

---

## Response Format

Routes must define a response structure. The response can reference pipeline variables:

```json
{
  "response": {
    "status": 200,
    "headers": {
      "Content-Type": "application/json",
      "X-Request-ID": { "$get": "requestId" }
    },
    "body": { "$get": "response" }
  }
}
```

Responses can also be conditional:
```json
{
  "response": {
    "$if": {
      "condition": { "$exists": { "$get": "post" } },
      "then": { "status": 200, "body": { "$get": "post" } },
      "else": { "status": 404, "body": { "error": "Not found" } }
    }
  }
}
```

---

## Complete Example

```json
{
  "database": {
    "schemas": {
      "posts": {
        "fields": {
          "id": { "type": "string", "required": true, "primary": true },
          "title": { "type": "string", "required": true },
          "body": { "type": "string", "required": true },
          "authorId": { "type": "string", "required": true },
          "published": { "type": "boolean", "default": false },
          "createdAt": { "type": "datetime", "required": true },
          "updatedAt": { "type": "datetime" }
        }
      },
      "users": {
        "fields": {
          "id": { "type": "string", "required": true, "primary": true },
          "email": { "type": "string", "required": true, "unique": true },
          "name": { "type": "string", "required": true },
          "avatar": { "type": "string" }
        }
      }
    }
  },
  "templates": {
    "path": "./templates",
    "engine": "jinja",
    "files": {
      "postDetail": "posts/detail.html"
    }
  },
  "middleware": {
    "authenticate": {
      "pipeline": [
        {
          "name": "user",
          "value": {
            "$if": {
              "condition": { "$exists": { "$get": "headers.authorization" } },
              "then": { "$decodeJWT": { "$get": "headers.authorization" } },
              "else": { "$return": { "status": 401, "body": { "error": "Unauthorized" } } }
            }
          }
        }
      ]
    }
  },
  "routes": [
    {
      "path": "/api/v1/posts/:id",
      "method": "GET",
      "pipeline": [
        {
          "name": "post",
          "value": {
            "$dbQuery": {
              "collection": "posts",
              "filter": { "id": { "$get": "params.id" } }
            }
          }
        },
        {
          "name": "author",
          "value": {
            "$if": {
              "condition": { "$exists": { "$get": "post" } },
              "then": {
                "$dbQuery": {
                  "collection": "users",
                  "filter": { "id": { "$get": "post.authorId" } },
                  "select": ["name", "avatar"]
                }
              },
              "else": { "$return": { "status": 404, "body": { "error": "Post not found" } } }
            }
          }
        },
        {
          "name": "response",
          "value": {
            "$merge": [
              { "$get": "post" },
              { "author": { "$get": "author" } }
            ]
          }
        }
      ],
      "response": {
        "status": 200,
        "body": { "$get": "response" }
      }
    },
    {
      "path": "/api/v1/posts",
      "method": "POST",
      "middleware": ["authenticate"],
      "pipeline": [
        {
          "value": {
            "$validate": {
              "data": { "$get": "body" },
              "schema": {
                "type": "object",
                "properties": {
                  "title": { "type": "string", "minLength": 1 },
                  "body": { "type": "string" }
                },
                "required": ["title", "body"]
              }
            }
          }
        },
        {
          "name": "newPost",
          "value": {
            "$dbInsert": {
              "collection": "posts",
              "document": {
                "title": { "$get": "body.title" },
                "body": { "$get": "body.body" },
                "authorId": { "$get": "user.id" },
                "published": false,
                "createdAt": { "$now": null }
              },
              "validate": true
            }
          }
        }
      ],
      "response": {
        "status": 201,
        "body": { "$get": "newPost" }
      }
    }
  ]
}
```

---

## Outstanding Questions & Future Decisions

### 1. Error Handling Strategy
- **Concept**: Error boundaries (like React/Svelte)
- **Scope**: Global handler + optional per-route handlers
- **Mechanism**: TBD - needs design
- **Questions**:
  - How do errors propagate through the pipeline?
  - Should there be try/catch-like operators?
  - How do validation failures integrate with error handling?

### 2. Type Field in Pipeline Steps
- **Current**: Optional, under consideration
- **Pros**: Self-documenting, easier to parse/validate
- **Cons**: Redundant with operator names
- **Decision needed**: Keep, remove, or make optional?

### 3. HTML Rendering & Templates
- **Goal**: Serve/render HTML, not just JSON
- **Template engine**: Jinja, Handlebars, EJS, or custom?
- **Configuration**: Reserved in config, details TBD
- **Questions**:
  - Component reusability?
  - Partials/includes?
  - Layout inheritance?
  - Client-side hydration?

### 4. Advanced Operators
Potential additions:
- `$join` - SQL-like joins across collections
- `$groupBy` - Aggregation
- `$try` - Error handling within pipeline
- `$parallel` - Execute multiple queries concurrently
- `$cache` - Cache results
- Math operators: `$add`, `$subtract`, `$multiply`, `$divide`
- Comparison operators: `$eq`, `$ne`, `$gt`, `$lt`, `$gte`, `$lte`
- Logical operators: `$and`, `$or`, `$not`
- `$renderTemplate` - Render HTML templates

### 5. Middleware Execution Model
- **Question**: Is `$next` explicit or implicit?
- **Current thinking**: Implicit unless `$return` is called
- **Alternative**: Require explicit `$next` call to continue

### 6. Response vs. Early Return
- **Current**: Routes have a `response` field, but pipelines can `$return` early
- **Question**: Is this confusing? Should all returns go through the response field?
- **Trade-off**: Flexibility vs. consistency

### 7. Database Query Language
- **Current**: Simple filter objects (MongoDB-like)
- **Future**: May need more advanced query capabilities
- **Questions**:
  - Joins/relationships?
  - Full-text search?
  - Aggregations?

### 8. Configuration Format
- **Current**: JSON (standard)
- **Alternatives**: JSON5 (comments, trailing commas), YAML (more readable), TOML
- **Trade-off**: Tooling support vs. ergonomics

### 9. Database Schema Usage
- **Current**: Optional, used for documentation and optional validation
- **Future possibilities**:
  - Auto-generate CRUD endpoints
  - Generate TypeScript types
  - Database migrations
  - Query optimization hints

---

## Design Principles Summary

1. **Start simple, expand carefully**: Basic operators first, advanced features later
2. **Composition over complexity**: Small operators that nest, not monolithic constructs
3. **Declarative boundaries**: Complex logic should push users toward custom handlers (future feature)
4. **Self-contained config**: Everything needed to understand a route should be in the route definition (or clearly referenced)
5. **Fail fast**: Validation and error handling should be explicit and early in the pipeline

---

## Next Steps

1. Implement core pipeline executor
2. Implement basic operators (`$get`, `$if`, `$dbQuery`, `$dbInsert`)
3. Build simple example (CRUD API)
4. Iterate on ergonomics based on real usage
5. Add middleware support
6. Design error handling system
7. Expand operator library based on common patterns
8. Design and implement template rendering system