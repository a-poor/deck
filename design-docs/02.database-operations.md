# Database Operations DSL Design

**Status**: Design Phase
**Created**: 2025-01-17
**Purpose**: Define the declarative DSL for database operations before implementation

---

## Table of Contents

1. [Overview & Philosophy](#overview--philosophy)
2. [Filter Expression Language](#filter-expression-language)
3. [Query Operator ($dbQuery)](#query-operator-dbquery)
4. [Insert Operator ($dbInsert)](#insert-operator-dbinsert)
5. [Update Operator ($dbUpdate)](#update-operator-dbupdate)
6. [Delete Operator ($dbDelete)](#delete-operator-dbdelete)
7. [Schema Integration](#schema-integration)
8. [Common Patterns & Examples](#common-patterns--examples)
9. [Error Handling](#error-handling)
10. [Edge Cases & Design Decisions](#edge-cases--design-decisions)
11. [Future Considerations](#future-considerations)
12. [Implementation Guidance](#implementation-guidance)

---

## Overview & Philosophy

### Data Model

Deck treats the database as a **document store** where:
- Each collection contains JSON documents
- Documents are schemaless by default (schema validation is optional)
- Documents are identified by a unique ID field
- Relationships are modeled through references (foreign keys) or embedded documents

### Design Principles

1. **Declarative over imperative**: Express *what* to query, not *how* to query it
2. **Composable with operators**: Filter expressions can use any operator (`$get`, `$eq`, `$gt`, etc.)
3. **Schema-optional**: Works without schemas, enhanced with schemas
4. **Predictable**: Clear semantics for edge cases (empty filters, no matches, etc.)
5. **Trait-based implementation**: DSL is separate from actual database backend

### Separation of Concerns

- **DSL Layer** (this document): Defines the operator syntax and semantics
- **Executor Layer**: Evaluates operators in filter expressions
- **Database Provider Trait**: Abstracts the actual database implementation
- **Implementation Layer**: Specific database backends (in-memory, SQLite, MongoDB, etc.)

---

## Filter Expression Language

The filter language is the **most critical** part of the database DSL. It determines how queries are expressed and must be both powerful and intuitive.

### Filter Structure

Filters are JSON objects where:
- Keys are field names (or special operators)
- Values are either literals, operators, or nested filter objects

### Simple Equality Filters

The simplest filter is direct field equality:

```json
{
  "filter": {
    "status": "published",
    "authorId": "user-123"
  }
}
```

This matches documents where `status == "published" AND authorId == "user-123"`.

**With operators**:
```json
{
  "filter": {
    "authorId": {"$get": "user.id"},
    "status": "published"
  }
}
```

### Comparison Operators in Filters

To express non-equality comparisons, wrap the field value:

```json
{
  "filter": {
    "age": {"$gt": 18}
  }
}
```

**Supported comparison operators**:
- `$eq`: Equality (same as direct value)
- `$ne`: Not equal
- `$gt`: Greater than
- `$gte`: Greater than or equal
- `$lt`: Less than
- `$lte`: Less than or equal

**Range queries**:
```json
{
  "filter": {
    "price": {
      "$gte": 10,
      "$lte": 100
    }
  }
}
```

This matches documents where `price >= 10 AND price <= 100`.

### Logical Operators in Filters

Combine multiple conditions using logical operators:

**AND (implicit)**: All top-level fields are ANDed together
```json
{
  "filter": {
    "status": "published",
    "age": {"$gt": 18}
  }
}
```
Equivalent to: `status == "published" AND age > 18`

**AND (explicit)**:
```json
{
  "filter": {
    "$and": [
      {"status": "published"},
      {"age": {"$gt": 18}}
    ]
  }
}
```

**OR**:
```json
{
  "filter": {
    "$or": [
      {"status": "published"},
      {"status": "draft"}
    ]
  }
}
```

**NOT**:
```json
{
  "filter": {
    "$not": {
      "deleted": true
    }
  }
}
```

**Complex combinations**:
```json
{
  "filter": {
    "$and": [
      {
        "$or": [
          {"category": "tech"},
          {"category": "science"}
        ]
      },
      {"published": true},
      {"views": {"$gt": 100}}
    ]
  }
}
```

This matches: `(category == "tech" OR category == "science") AND published == true AND views > 100`

### Special Query Operators

**$in**: Match any value in an array
```json
{
  "filter": {
    "status": {"$in": ["draft", "published", "archived"]}
  }
}
```

**$nin**: Not in array
```json
{
  "filter": {
    "status": {"$nin": ["deleted", "spam"]}
  }
}
```

**$exists**: Check if field exists
```json
{
  "filter": {
    "deletedAt": {"$exists": false}
  }
}
```

**$regex**: Regular expression matching (string fields only)
```json
{
  "filter": {
    "email": {"$regex": ".*@example\\.com$"}
  }
}
```

**$contains**: Array contains value
```json
{
  "filter": {
    "tags": {"$contains": "javascript"}
  }
}
```

**$size**: Array size
```json
{
  "filter": {
    "tags": {"$size": 3}
  }
}
```

### Nested Field Queries

Use dot notation to query nested fields:

```json
{
  "filter": {
    "user.email": "alice@example.com",
    "user.profile.verified": true
  }
}
```

### Array Queries

**Contains specific value**:
```json
{
  "filter": {
    "tags": {"$contains": "javascript"}
  }
}
```

**All values match**:
```json
{
  "filter": {
    "tags": {"$all": ["javascript", "typescript"]}
  }
}
```

**Element matches condition**:
```json
{
  "filter": {
    "comments": {
      "$elemMatch": {
        "author": "alice",
        "approved": true
      }
    }
  }
}
```

### Filter Evaluation

**Critical Design Decision**: Who evaluates the operators in filters?

**Option A**: Executor evaluates all OperatorValues first
- Filter: `{"authorId": {"$get": "user.id"}}`
- Executor evaluates `{"$get": "user.id"}` → `"user-123"`
- Passes to DB: `{"authorId": "user-123"}`
- **Pro**: Consistent operator evaluation, database doesn't need to know about operators
- **Con**: Can't push complex logic to database

**Option B**: Pass filters with operators to database provider
- Filter: `{"age": {"$gt": {"$get": "minAge"}}}`
- Passes entire filter structure to DB
- DB provider evaluates operators
- **Pro**: Database could optimize queries
- **Con**: Inconsistent evaluation, complex database providers

**✅ Decision: Option A** - Executor evaluates all OperatorValues in filters before passing to database provider. This keeps the database provider simple and operator evaluation consistent.

---

## Query Operator ($dbQuery)

Retrieve documents from a collection based on filter criteria.

### Signature

```json
{
  "$dbQuery": {
    "collection": "string",
    "filter": Object<string, OperatorValue> | null,
    "select": Array<string> | null,
    "limit": number | null,
    "skip": number | null,
    "sort": Object<string, "asc" | "desc"> | null
  }
}
```

### Parameters

- **collection** (required): Collection name to query
- **filter** (optional): Filter criteria (default: match all)
- **select** (optional): Fields to include in results (projection)
- **limit** (optional): Maximum number of documents to return
- **skip** (optional): Number of documents to skip (pagination)
- **sort** (optional): Field(s) to sort by

### Examples

**Get all posts**:
```json
{
  "$dbQuery": {
    "collection": "posts"
  }
}
```

**Get single post by ID**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "id": {"$get": "params.id"}
    }
  }
}
```

**Get published posts with pagination**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "published": true
    },
    "select": ["id", "title", "excerpt", "createdAt"],
    "sort": {
      "createdAt": "desc"
    },
    "limit": 10,
    "skip": {"$get": "query.offset"}
  }
}
```

**Complex filter with multiple conditions**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "$and": [
        {"published": true},
        {"views": {"$gt": 100}},
        {
          "$or": [
            {"category": "tech"},
            {"category": "science"}
          ]
        }
      ]
    },
    "limit": 20
  }
}
```

### Return Value

**Always returns an array**, even if 0 or 1 results:
- No matches: `[]`
- One match: `[{...}]`
- Multiple matches: `[{...}, {...}, ...]`

This is consistent and simplifies pipeline logic (no need to check if single object vs array).

### Error Cases

- **Collection not found**: `DatabaseError`
- **Invalid filter**: `ExecutionError` during filter evaluation
- **Database connection error**: `DatabaseError`

---

## Insert Operator ($dbInsert)

Insert a new document into a collection.

### Signature

```json
{
  "$dbInsert": {
    "collection": "string",
    "document": Object<string, OperatorValue>,
    "validate": boolean (default: false)
  }
}
```

### Parameters

- **collection** (required): Collection name
- **document** (required): Document to insert (fields can use operators)
- **validate** (optional): Validate against schema if `database.schemas[collection]` exists

### Examples

**Simple insert**:
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "authorId": {"$get": "user.id"},
      "published": false,
      "createdAt": {"$now": null}
    }
  }
}
```

**Insert with validation**:
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "authorId": {"$get": "user.id"},
      "createdAt": {"$now": null}
    },
    "validate": true
  }
}
```

**Insert with computed fields**:
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": {"$get": "body.title"},
      "slug": {
        "$renderString": "{{title}}-{{timestamp}}"
      },
      "metadata": {
        "$merge": [
          {"$get": "body.metadata"},
          {
            "createdBy": {"$get": "user.id"},
            "ipAddress": {"$get": "request.ip"}
          }
        ]
      }
    }
  }
}
```

### Return Value

Returns the **inserted document** including any generated fields (e.g., auto-generated ID):

```json
{
  "id": "auto-generated-id",
  "title": "My Post",
  "content": "...",
  "authorId": "user-123",
  "published": false,
  "createdAt": "2025-01-17T12:00:00Z"
}
```

### ID Generation

- If `id` field is provided: Use it (must be unique)
- If `id` field is missing: Database provider generates one (UUID, auto-increment, etc.)
- ID generation strategy is implementation-specific

### Error Cases

- **Validation failure** (if `validate: true`): `ValidationError`
- **Unique constraint violation**: `DatabaseError`
- **Required field missing** (if validated): `ValidationError`
- **Invalid field type** (if validated): `ValidationError`

---

## Update Operator ($dbUpdate)

Update existing documents in a collection.

### Signature

```json
{
  "$dbUpdate": {
    "collection": "string",
    "filter": Object<string, OperatorValue>,
    "update": Object<string, OperatorValue>,
    "validate": boolean (default: false)
  }
}
```

### Parameters

- **collection** (required): Collection name
- **filter** (required): Filter to select documents to update
- **update** (required): Fields to update
- **validate** (optional): Validate updated document against schema

### Update Semantics

**✅ Decision: Partial update (merge)**

The `update` object specifies fields to update. Unspecified fields remain unchanged.

```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "update": {
      "title": {"$get": "body.title"},
      "updatedAt": {"$now": null}
    }
  }
}
```

This updates **only** `title` and `updatedAt`. Fields like `content`, `authorId`, etc. remain unchanged.

### Atomic Update Operators (Future)

For more complex updates, special operators:

**$inc**: Increment a number
```json
{
  "update": {
    "views": {"$inc": 1},
    "likes": {"$inc": {"$get": "body.likeDelta"}}
  }
}
```

**$push**: Append to array
```json
{
  "update": {
    "tags": {"$push": "new-tag"}
  }
}
```

**$pull**: Remove from array
```json
{
  "update": {
    "tags": {"$pull": "old-tag"}
  }
}
```

**$set**: Explicit set (same as default)
```json
{
  "update": {
    "$set": {
      "title": "New Title"
    }
  }
}
```

**$unset**: Remove field
```json
{
  "update": {
    "$unset": ["tempField", "deprecatedField"]
  }
}
```

**✅ Decision: Start with simple merge, add atomic operators later**

### Examples

**Update single document**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {
      "id": {"$get": "params.id"}
    },
    "update": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "updatedAt": {"$now": null}
    }
  }
}
```

**Update multiple documents**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {
      "authorId": {"$get": "user.id"},
      "status": "draft"
    },
    "update": {
      "status": "archived",
      "archivedAt": {"$now": null}
    }
  }
}
```

**Conditional update**:
```json
{
  "name": "updateIfPublished",
  "value": {
    "$if": {
      "condition": {
        "$eq": [
          {"$get": "post.status"},
          "published"
        ]
      },
      "then": {
        "$dbUpdate": {
          "collection": "posts",
          "filter": {"id": {"$get": "post.id"}},
          "update": {
            "featured": true,
            "featuredAt": {"$now": null}
          }
        }
      },
      "else": null
    }
  }
}
```

### Return Value

Returns an **array of updated documents** (their full state after update):

```json
[
  {
    "id": "post-123",
    "title": "Updated Title",
    "content": "...",
    "updatedAt": "2025-01-17T12:00:00Z"
  }
]
```

- No matches: `[]`
- One match: `[{...}]`
- Multiple matches: `[{...}, {...}]`

### Error Cases

- **No documents match filter**: Not an error, returns `[]`
- **Validation failure**: `ValidationError`
- **Database constraint violation**: `DatabaseError`

---

## Delete Operator ($dbDelete)

Delete documents from a collection.

### Signature

```json
{
  "$dbDelete": {
    "collection": "string",
    "filter": Object<string, OperatorValue>
  }
}
```

### Parameters

- **collection** (required): Collection name
- **filter** (required): Filter to select documents to delete

### Examples

**Delete single document**:
```json
{
  "$dbDelete": {
    "collection": "posts",
    "filter": {
      "id": {"$get": "params.id"}
    }
  }
}
```

**Delete multiple documents**:
```json
{
  "$dbDelete": {
    "collection": "posts",
    "filter": {
      "authorId": {"$get": "user.id"},
      "status": "draft"
    }
  }
}
```

### Return Value

Returns an **array of deleted documents** (for audit trail):

```json
[
  {
    "id": "post-123",
    "title": "Deleted Post",
    "status": "draft",
    ...
  }
]
```

This allows the application to:
- Log what was deleted
- Implement undo functionality
- Trigger cascading operations

### Soft Delete Pattern

**✅ Recommendation**: Implement soft deletes at the application layer, not in the operator.

```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "update": {
      "deleted": true,
      "deletedAt": {"$now": null},
      "deletedBy": {"$get": "user.id"}
    }
  }
}
```

Then filter out deleted documents in queries:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "$or": [
        {"deleted": {"$exists": false}},
        {"deleted": false}
      ]
    }
  }
}
```

### Error Cases

- **No documents match filter**: Not an error, returns `[]`
- **Database constraint violation** (e.g., foreign key): `DatabaseError`

---

## Schema Integration

Schemas are defined in the top-level `database.schemas` configuration:

```json
{
  "database": {
    "schemas": {
      "posts": {
        "fields": {
          "id": { "type": "string", "required": true, "primary": true },
          "title": { "type": "string", "required": true, "minLength": 1 },
          "content": { "type": "string", "required": true },
          "authorId": { "type": "string", "required": true },
          "published": { "type": "boolean", "default": false },
          "tags": { "type": "array", "items": { "type": "string" } },
          "createdAt": { "type": "datetime", "required": true },
          "updatedAt": { "type": "datetime" }
        }
      }
    }
  }
}
```

### Validation Process

When `validate: true` is specified:

1. **Evaluate operators** in document/update fields
2. **Construct final document** (for insert) or **merge with existing** (for update)
3. **Validate against schema**:
   - Check required fields present
   - Validate field types
   - Check constraints (minLength, minimum, etc.)
   - Apply defaults for missing optional fields
4. **Return ValidationError** if validation fails

### Schema Validation vs JSON Schema Validation

**Two different types of validation**:

1. **Database Schema** (`database.schemas`):
   - Validates database documents
   - Defined in database configuration
   - Used with `validate: true` in db operators

2. **JSON Schema** (`$validate` operator):
   - Validates arbitrary data (request bodies, computed values, etc.)
   - Defined inline or in `schemas` section
   - Used explicitly in pipeline

**Example combining both**:
```json
{
  "pipeline": [
    {
      "name": "validatedInput",
      "value": {
        "$validate": {
          "data": {"$get": "body"},
          "schema": {
            "type": "object",
            "properties": {
              "title": {"type": "string", "minLength": 1},
              "content": {"type": "string"}
            },
            "required": ["title", "content"]
          },
          "onFail": {
            "$return": {
              "status": 400,
              "body": {"error": "Invalid input"}
            }
          }
        }
      }
    },
    {
      "name": "post",
      "value": {
        "$dbInsert": {
          "collection": "posts",
          "document": {
            "title": {"$get": "validatedInput.title"},
            "content": {"$get": "validatedInput.content"},
            "authorId": {"$get": "user.id"},
            "createdAt": {"$now": null}
          },
          "validate": true
        }
      }
    }
  ]
}
```

---

## Common Patterns & Examples

### CRUD Operations

**Create**:
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "authorId": {"$get": "user.id"},
      "published": false,
      "createdAt": {"$now": null}
    },
    "validate": true
  }
}
```

**Read (single)**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "limit": 1
  }
}
```

**Read (list with pagination)**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {"published": true},
    "select": ["id", "title", "excerpt", "createdAt"],
    "sort": {"createdAt": "desc"},
    "limit": 20,
    "skip": {"$get": "query.offset"}
  }
}
```

**Update**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "update": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "updatedAt": {"$now": null}
    },
    "validate": true
  }
}
```

**Delete**:
```json
{
  "$dbDelete": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}}
  }
}
```

### Relationships (Manual Foreign Keys)

**Get post with author (two queries)**:
```json
{
  "pipeline": [
    {
      "name": "post",
      "value": {
        "$dbQuery": {
          "collection": "posts",
          "filter": {"id": {"$get": "params.id"}}
        }
      }
    },
    {
      "name": "author",
      "value": {
        "$dbQuery": {
          "collection": "users",
          "filter": {
            "id": {
              "$get": "post.0.authorId"
            }
          },
          "select": ["id", "name", "avatar"]
        }
      }
    },
    {
      "name": "response",
      "value": {
        "$merge": [
          {"$get": "post.0"},
          {
            "author": {"$get": "author.0"}
          }
        ]
      }
    }
  ]
}
```

**Get user's posts (one-to-many)**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "authorId": {"$get": "params.userId"}
    },
    "sort": {"createdAt": "desc"},
    "limit": 10
  }
}
```

### Search Patterns

**Simple text search**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "title": {
        "$regex": {"$get": "query.q"}
      }
    },
    "limit": 20
  }
}
```

**Multi-field search**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "$or": [
        {"title": {"$regex": {"$get": "query.q"}}},
        {"content": {"$regex": {"$get": "query.q"}}},
        {"tags": {"$contains": {"$get": "query.q"}}}
      ]
    }
  }
}
```

### Pagination Patterns

**Offset-based (traditional)**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {"published": true},
    "sort": {"createdAt": "desc"},
    "limit": 20,
    "skip": {"$get": "query.page * 20"}
  }
}
```

**Cursor-based (more efficient for large datasets)**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "$and": [
        {"published": true},
        {"createdAt": {"$lt": {"$get": "query.cursor"}}}
      ]
    },
    "sort": {"createdAt": "desc"},
    "limit": 20
  }
}
```

### Audit Trails

**Automatic timestamps**:
```json
{
  "$dbInsert": {
    "collection": "posts",
    "document": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "createdAt": {"$now": null},
      "createdBy": {"$get": "user.id"},
      "updatedAt": {"$now": null},
      "updatedBy": {"$get": "user.id"}
    }
  }
}
```

**Update tracking**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "update": {
      "title": {"$get": "body.title"},
      "content": {"$get": "body.content"},
      "updatedAt": {"$now": null},
      "updatedBy": {"$get": "user.id"}
    }
  }
}
```

### Soft Deletes

**Mark as deleted**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": {"$get": "params.id"}},
    "update": {
      "deleted": true,
      "deletedAt": {"$now": null},
      "deletedBy": {"$get": "user.id"}
    }
  }
}
```

**Query excluding deleted**:
```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {
      "$and": [
        {"published": true},
        {
          "$or": [
            {"deleted": {"$exists": false}},
            {"deleted": false}
          ]
        }
      ]
    }
  }
}
```

### Conditional Operations

**Update only if owned by user**:
```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {
      "$and": [
        {"id": {"$get": "params.id"}},
        {"authorId": {"$get": "user.id"}}
      ]
    },
    "update": {
      "title": {"$get": "body.title"}
    }
  }
}
```

Result will be empty array `[]` if user doesn't own the post, which can be checked:

```json
{
  "pipeline": [
    {
      "name": "updated",
      "value": {
        "$dbUpdate": {
          "collection": "posts",
          "filter": {
            "$and": [
              {"id": {"$get": "params.id"}},
              {"authorId": {"$get": "user.id"}}
            ]
          },
          "update": {
            "title": {"$get": "body.title"}
          }
        }
      }
    },
    {
      "name": "response",
      "value": {
        "$if": {
          "condition": {
            "$gt": [
              {"$jsonPath": "$.updated.length"},
              0
            ]
          },
          "then": {
            "status": 200,
            "body": {"$get": "updated.0"}
          },
          "else": {
            "status": 403,
            "body": {"error": "Not authorized"}
          }
        }
      }
    }
  ]
}
```

---

## Error Handling

### Database Errors

All database operations can fail with `DatabaseError`:

```rust
ExecutionError::DatabaseError {
    message: String
}
```

**Common causes**:
- Connection timeout
- Collection/table not found
- Constraint violation (unique, foreign key)
- Disk full / storage errors
- Permission errors

**Handling in pipeline**:
Database errors propagate up and terminate the pipeline. Use middleware or error boundaries (future) to catch and handle them.

### Validation Errors

When `validate: true` is specified:

```rust
ExecutionError::ValidationError {
    message: String,
    errors: Vec<String>
}
```

**Causes**:
- Required field missing
- Type mismatch
- Constraint violation (minLength, minimum, etc.)
- Invalid enum value

**Handling**:
Validation errors should be caught and returned as 400 Bad Request:

```json
{
  "pipeline": [
    {
      "name": "post",
      "value": {
        "$dbInsert": {
          "collection": "posts",
          "document": {
            "title": {"$get": "body.title"},
            "content": {"$get": "body.content"}
          },
          "validate": true
        }
      }
    }
  ],
  "onError": {
    "validationError": {
      "status": 400,
      "body": {
        "error": "Validation failed",
        "details": {"$get": "error.errors"}
      }
    }
  }
}
```

(Note: `onError` handling is a future feature, not yet implemented)

### Not Found Scenarios

**Query returns no results**: Not an error, returns `[]`

**Update/Delete matches nothing**: Not an error, returns `[]`

This is intentional - no results is a valid state. Applications should check:

```json
{
  "$if": {
    "condition": {
      "$eq": [
        {"$jsonPath": "$.post.length"},
        0
      ]
    },
    "then": {
      "$return": {
        "status": 404,
        "body": {"error": "Post not found"}
      }
    },
    "else": {
      "status": 200,
      "body": {"$get": "post.0"}
    }
  }
}
```

---

## Edge Cases & Design Decisions

### Empty Filters

**Question**: What does an empty filter mean?

```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {}
  }
}
```

**✅ Decision**: Empty filter matches **all documents** (with safety limits).

This is consistent with MongoDB and SQL (`WHERE 1=1`). However:

- **Always apply a reasonable default limit** (e.g., 1000 documents max)
- **Require explicit limit: null** to override
- **Log warning** if no filter and no limit

```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": {},  // Match all
    "limit": null  // No limit (dangerous!)
  }
}
```

### Null Filters

**Question**: What does `filter: null` mean?

```json
{
  "$dbQuery": {
    "collection": "posts",
    "filter": null
  }
}
```

**✅ Decision**: Same as empty filter `{}` - matches all documents.

### Filter Evaluation Order

**Question**: When are operators in filters evaluated?

**✅ Decision**: **Before** the database call, in left-to-right order:

```json
{
  "filter": {
    "authorId": {"$get": "user.id"},  // Evaluated first
    "status": "published"              // Then this
  }
}
```

Evaluation happens during the `eval_operator()` call for `$dbQuery`, before calling `database.query()`.

### Null Handling in Filters

**Question**: How are null values handled in filters?

```json
{
  "filter": {
    "deletedAt": null
  }
}
```

**✅ Decision**: Matches documents where `deletedAt` field is `null` or doesn't exist.

For explicit existence checks:
```json
{
  "filter": {
    "deletedAt": {"$exists": false}  // Doesn't exist
  }
}
```

```json
{
  "filter": {
    "deletedAt": {"$exists": true}   // Exists (even if null)
  }
}
```

### Type Coercion in Comparisons

**Question**: Should `"123"` == `123` match?

**✅ Decision**: **No type coercion**. Strict equality, consistent with operators.

```json
{
  "filter": {
    "age": "18"  // String "18"
  }
}
```

This will **not** match documents where `age` is the number `18`.

### Case Sensitivity in String Comparisons

**Question**: Is `"hello"` == `"Hello"`?

**✅ Decision**: **Case-sensitive by default**.

For case-insensitive:
```json
{
  "filter": {
    "email": {"$regex": "(?i)alice@example\\.com"}
  }
}
```

### Pagination Edge Cases

**Question**: What happens if `skip` is beyond the end?

```json
{
  "filter": {},
  "skip": 10000,
  "limit": 10
}
```

**✅ Decision**: Returns empty array `[]`. Not an error.

**Question**: What happens if `limit` is negative?

**✅ Decision**: Treat as invalid parameter, return error.

### Update with No Matches

**Question**: Is it an error if update matches no documents?

```json
{
  "$dbUpdate": {
    "collection": "posts",
    "filter": {"id": "non-existent"},
    "update": {"title": "New Title"}
  }
}
```

**✅ Decision**: **Not an error**. Returns empty array `[]`.

This allows idempotent updates and simplified logic.

### Delete with No Matches

**✅ Decision**: Same as update - not an error, returns `[]`.

### Multiple Sort Fields

**Question**: How to handle multiple sort fields?

```json
{
  "sort": {
    "published": "desc",
    "createdAt": "desc"
  }
}
```

**✅ Decision**: Sort by `published` first, then by `createdAt` (tie-breaker).

Order is determined by:
1. **JSON object key order** (insertion order in most implementations)
2. **Alphabetical** if implementation doesn't preserve order

**Recommendation**: Use array of objects for explicit order (future):
```json
{
  "sort": [
    {"published": "desc"},
    {"createdAt": "desc"}
  ]
}
```

### Transaction Atomicity

**Question**: Are individual operations atomic?

**✅ Decision**: Each database operation (`$dbQuery`, `$dbInsert`, `$dbUpdate`, `$dbDelete`) is **atomic** within itself.

**Multi-document operations** (e.g., `$dbUpdate` matching multiple docs) should be atomic if the database supports it.

**Cross-operation transactions** are **not supported** in the initial implementation. Future consideration: `$transaction` operator.

### Schema Validation Timing

**Question**: When is schema validation performed?

**✅ Decision**: After all operators in document/update are evaluated, before database call.

Flow:
1. Evaluate all OperatorValues in `document`/`update`
2. Construct final document/update object
3. If `validate: true`, validate against schema
4. If valid, pass to database provider
5. If invalid, return ValidationError

---

## Future Considerations

### Aggregation Pipelines

Support complex aggregations similar to MongoDB:

```json
{
  "$dbAggregate": {
    "collection": "posts",
    "pipeline": [
      {"$match": {"published": true}},
      {"$group": {
        "by": "authorId",
        "aggregates": {
          "count": {"$count": null},
          "avgViews": {"$avg": "views"}
        }
      }},
      {"$sort": {"count": "desc"}},
      {"$limit": 10}
    ]
  }
}
```

### Full-Text Search

Dedicated search operators:

```json
{
  "$dbSearch": {
    "collection": "posts",
    "text": {"$get": "query.q"},
    "fields": ["title", "content"],
    "fuzzy": true,
    "limit": 20
  }
}
```

### Geospatial Queries

For location-based searches:

```json
{
  "$dbQuery": {
    "collection": "stores",
    "filter": {
      "location": {
        "$near": {
          "lat": {"$get": "query.lat"},
          "lng": {"$get": "query.lng"},
          "maxDistance": 5000  // meters
        }
      }
    }
  }
}
```

### Graph/Relationship Traversal

For nested relationships:

```json
{
  "$dbGraph": {
    "collection": "users",
    "start": {"id": {"$get": "user.id"}},
    "traverse": {
      "edge": "friends",
      "maxDepth": 2
    }
  }
}
```

### Real-Time Subscriptions

Live query updates:

```json
{
  "$dbSubscribe": {
    "collection": "messages",
    "filter": {
      "channelId": {"$get": "params.channelId"}
    },
    "onChange": {
      // Trigger when matching documents change
    }
  }
}
```

### Batch Operations

Insert/update/delete multiple items:

```json
{
  "$dbBatchInsert": {
    "collection": "posts",
    "documents": [
      {...},
      {...},
      {...}
    ]
  }
}
```

### Transactions

Multi-operation transactions:

```json
{
  "$transaction": {
    "operations": [
      {
        "$dbUpdate": {
          "collection": "accounts",
          "filter": {"id": "acc-1"},
          "update": {"balance": {"$inc": -100}}
        }
      },
      {
        "$dbUpdate": {
          "collection": "accounts",
          "filter": {"id": "acc-2"},
          "update": {"balance": {"$inc": 100}}
        }
      }
    ],
    "onError": "rollback"
  }
}
```

### Database-Level Constraints

Define constraints in schema:

```json
{
  "database": {
    "schemas": {
      "posts": {
        "fields": {
          "id": {
            "type": "string",
            "primary": true
          },
          "slug": {
            "type": "string",
            "unique": true
          },
          "authorId": {
            "type": "string",
            "foreignKey": {
              "collection": "users",
              "field": "id",
              "onDelete": "cascade"
            }
          }
        }
      }
    }
  }
}
```

---

## Implementation Guidance

### Filter Evaluation Algorithm

**Step-by-step for `$dbQuery`**:

1. **Extract filter from operator**: `op.filter`
2. **If filter is None**: Use empty HashMap
3. **Evaluate each field value**:
   ```rust
   let mut evaluated_filter = HashMap::new();
   for (key, value) in filter {
       let evaluated_value = self.eval(context, value)?;
       evaluated_filter.insert(key.clone(), evaluated_value);
   }
   ```
4. **Pass evaluated filter to database provider**:
   ```rust
   let results = self.database.query(
       &op.collection,
       Some(&evaluated_filter),
       op.select.as_deref(),
       op.limit,
       op.skip,
       op.sort.as_ref()
   )?;
   ```
5. **Return results as JSON array**

**Note**: Special filter operators like `$and`, `$or`, `$not` need special handling - they should be evaluated by the executor into a single boolean condition, or converted to a database-specific query format.

### Database Provider Implementation

The `DatabaseProvider` trait receives:
- **Evaluated filters**: All OperatorValues have been resolved to plain Values
- **Plain values**: No need to understand operators

Example mock implementation:
```rust
fn query(
    &self,
    collection: &str,
    filter: Option<&HashMap<String, Value>>,
    select: Option<&[String]>,
    limit: Option<u32>,
    skip: Option<u32>,
    sort: Option<&HashMap<String, SortOrder>>,
) -> Result<Vec<Value>, ExecutionError> {
    // 1. Get documents from collection
    let docs = self.get_collection(collection)?;

    // 2. Apply filter
    let filtered = docs.into_iter()
        .filter(|doc| matches_filter(doc, filter))
        .collect::<Vec<_>>();

    // 3. Apply sort
    let sorted = apply_sort(filtered, sort);

    // 4. Apply skip
    let skipped = sorted.into_iter()
        .skip(skip.unwrap_or(0) as usize);

    // 5. Apply limit
    let limited = skipped
        .take(limit.unwrap_or(1000) as usize);

    // 6. Apply projection
    let projected = limited
        .map(|doc| apply_projection(doc, select))
        .collect();

    Ok(projected)
}
```

### Test Strategy

**For each database operator**:

1. **Unit tests** (with MockDatabase):
   - Simple queries
   - Complex filters with logical operators
   - Pagination
   - Sorting
   - Empty results
   - Error cases

2. **Integration tests** (with in-memory database):
   - Full CRUD operations
   - Filter evaluation correctness
   - Schema validation
   - Concurrent operations

3. **Example configs**:
   - Blog CRUD API
   - Todo list API
   - E-commerce product catalog

### Mock Database Capabilities

The `MockDatabase` should support:
- **Pre-populated data**: Set up test data
- **Filter matching**: Simple equality, comparison operators
- **Sort/limit/skip**: Basic query operations
- **Insert/update/delete tracking**: Verify operations were called
- **Error injection**: Test error handling

Example:
```rust
let db = MockDatabase::new()
    .with_collection("posts", vec![
        json!({"id": "1", "title": "Post 1", "published": true}),
        json!({"id": "2", "title": "Post 2", "published": false}),
    ])
    .with_error_on_collection("broken", DatabaseError::custom("Simulated error"));
```

---

## Summary

This design document establishes:

1. **Clear filter language** with MongoDB-like syntax
2. **Consistent return values** (arrays for all operations)
3. **Explicit evaluation order** (executor evaluates operators before DB call)
4. **Schema integration** with optional validation
5. **Predictable edge cases** (empty filters, no matches, etc.)
6. **Future extensibility** (aggregations, full-text search, transactions)

The DSL is now ready for implementation with comprehensive tests and clear semantics.
